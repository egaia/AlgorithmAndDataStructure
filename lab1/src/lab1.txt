0.Järjestamismeetodid
    Abstraktne keerukus, konkreetne keerukus (keskmine, halvim), mäluvajadus, algoritmi lihtsus, stabiilsus, ...
    "Aeglased" meetodid: O(n2)
        lihtne pistemeetod
        mullimeetod
        valikumeetod
    "Kiired" meetodid: O(nlogn)
        kahendpistemeetod
        Shelli meetod
        kiirmeetod (Hoare'i meetod)
        kuhjameetod
        ühildusmeetod
    Erimeetodid (kitsendustega): O(n)
        loendamismeetod
        positsioonimeetod
        kimbumeetod
1.Algoritmi omadused. Algoritmide asümptootiline analüüs: relatsioonid "suur-O", "väike-o", teeta, "suur-oomega" ja "väike-oomega"; nende definitsioonid ning  põhiomadused.
    a) Algoritmi iseloomustamiseks kasutatakse järgmisi mõisteid:
        * Korrektsus (algoritm lahendab "õiget" ülesannet, tulemus vastab spetsifikatsioonile).
        * Määratletus (sammud on lõplikud ja üheselt määratud).
        * Kirjelduse lõplikkus (algoritm on kirjeldatav lõpliku arvu sammudega).
        * Peatuvus. Töö lõpetamine mistahes sisendi korral - kõikjal määratud algoritm. Osaline e. "poollahenduv" algoritm kas annab tulemuse või ei lõpeta tööd.
        * Determinism (samade algandmete korral vastus sama, lahenduskäik on korratav) vs. mittedeterminism (näit. "tõeline" juhuarvude generaator).
        * Universaalsus (lahendab probleemide klassi: sisend -> väljund ).
        * Keerukus (efektiivsus, kas lõpetamise aeg ja/või mälumaht on praktilised).

    b) Asümptootilised hinnangud, "suure O", "väikese o", "suure oomega", "väikese oomega" ja teeta-tähistused:
    "f kasvab mitte kiiremini kui g" ( f big-Oh g ) - leiduvad konstant c>0 ja koht N nii, et iga n>N korral
        |f(n)| < c|g(n)|
            f ja g suhe on ülalt tõkestatud.

    "f kasvab aeglasemalt kui g" ( f little-oh g ) - mistahes konstandi c>0 jaoks leidub koht N nii, et iga n>N korral
        |f(n)| < c|g(n)|
            f ja g suhe pole alt tõkestatud.
    "f kasvab niisama kiiresti kui g" ( f big-Theta g ) - leiduvad konstandid b, c>0 ja koht N nii, et iga n>N korral
        b|g(n)| < |f(n)| < c|g(n)|
            f ja g suhe on nii ülalt kui ka alt tõkestatud.
    "f kasvab mitte aeglasemalt kui g" ( f big-Omega g ) - "g kasvab mitte kiiremini kui f"
        f ja g suhe on alt tõkestatud.
    "f kasvab kiiremini kui g" ( f little-omega g ) - "g kasvab aeglasemalt kui f"
        f ja g suhe pole ülalt tõkestatud.
2.Kahendotsimine (binary search).
    "Lõigu poolitamine" matemaatikas. On rakendatav kahel eeltingimusel:
        1. vaadeldav struktuur on järjestatud
        2. elemendid on indekseeritavad
    O(log n)
    /**
    * Leida etteantud listist etteantud element kahendotsimise abil.
    * @param a list.
    * @param e otsitav element.
    * @returns otsitava elemendi indeks või -1, kui elementi ei leidu.
    */
    static public int otsi (List a, Comparable e) {
        int j = -1;
        int l = 0; // vasakpoolne otspunkt
        int r = a.size() - 1; // parempoolne otspunkt
        while (l <= r) {
            j = (l + r) / 2;
            if (e.compareTo ((Comparable)a.get (j)) == 0)
                return j;
            if (e.compareTo ((Comparable)a.get (j)) > 0)
                l = j+1; // vasak otspunkt nihkub paremale
            else
                r = j-1; // parem otspunkt nihkub vasakule
        };
        return -1;
    } // otsi lopp
3.Paisksalvestus, paisktabel (hash table).
    Hashing (paisksalvestus) - Elemendi asukoht massiivis leitakse rakendades võtmele hash funktsiooni.
    Mitme võtme sattumist samale kohale nimetatakse kokkupõrkeks. Kokkupõrke lahendamiseks on mitu meetodit
        ? avatud adresseerimine (lingitud listiga)
        ? rehash
    Hash otsingu keerukus - Halvimal juhul lineaarne otsing (O(n)) - Kõik elemendid on ühes lingitud listis.
    Parimal juhul konstantne otsing (O(1)) - Iga võti annab erineva hash väärtuse
4.Järjestamine: pistemeetod (insertion sort) ja kiirmeetod (quicksort).
    Pistemeetod:
        Jada jagatakse "järjestatud osaks" (algselt tühi) ja "järjestamata osaks" (algselt kogu jada).
        Järjestatud osa pikkust suurendatakse järjekordse elemendi paigutamisega õigele kohale järjestatud osas.

        /**
        * Sorteerida pistemeetodil List, mille elemendid realiseerivad
        * liidest Comparable.
        * @param a sorteeritav list.
        */
        static public void pisteSort (List a) {
            if (a.size() < 2) return;
            for (int i=1; i<a.size(); i++) {
                Comparable b = (Comparable) a.remove (i);
                int j;
                for (j=0; j<i; j++) {
                if (b.compareTo ((Comparable)a.get (j)) < 0) break;
                }
            a.add (j, b); // pistame b kohale j
            }
        } // pisteSort() lopp

        /**
        * Sorteerime massiivi, mille elemendid realiseerivad
        * liidest Comparable.
        * @param a sorteeritav massiiv.
        */
        static public void pisteSort (Comparable[] a) {
            if (a.length < 2) return;
            for (int i=1; i<a.length; i++) {
                Comparable b = a[i];
                int j;
                for (j=i-1; j>=0; j--) {
                    if (a[j].compareTo (b) <= 0) break;
                    a[j+1] = a[j]; // vabastame pistekoha
                }
                a[j+1] = b; // pistame b kohale
            }
        } // pisteSort() lopp

    Kiirmeetod:
        (Osa)jada jagatakse kaheks lühemaks osajadaks nii, et ükski element esimeses osas ei oleks suurem ühestki elemendist teises osas.
         Siis võib kummagi osa sorteerida eraldi (nad on   sõltumatud). "Jaga ja valitse"
        /**
        * Sorteerida massiiv kiirmeetodil.
        * @param massiiv sorteeritav massiiv.
        * @param l vasakpoolne otspunkt.
        * @param r parempoolne otspunkt.
        */
        static public void sort (Comparable[] massiiv, int l, int r) {
            if (massiiv.length < 2) return;
            int i = l; int j = r;
            Comparable x = massiiv [(i+j) / 2];
            do {
                while (massiiv [i].compareTo (x) < 0) i++;
                while (x.compareTo (massiiv [j]) < 0) j--;
                if (i <= j) {
                    Comparable tmp = massiiv [i];
                    massiiv [i] = massiiv [j]; massiiv [j] = tmp;
                    // selle koha peal on väljatrükk silumiseks: "veelahe" ja vahetatavad
                    i++; j--;
                }
            } while (i < j);
                if (l < j) sort (massiiv, l, j); // rekursioon
                if (i < r) sort (massiiv, i, r); // rekursioon
        } // sort() lopp

5.Jaga ja valitse: ühildusmeetod (merge sort).
    "Jaga ja valitse": jagatakse kogu aeg pooleks (kuni pikkus < 2), pooled ühendatakse lineaarse keerukusega ühildamise abil, kasutatakse lisamälu mahuga O(n)
6.Lineaarse keerukusega järjestamismeetodid: kimbumeetod (bucket sort), positsioonimeetod (radix sort) ja  loendamismeetod (counting sort).
    TODO!!
7.Abstraktsed andmetüübid (ADT), staatilised ja dünaamilised andmestruktuurid. Ahel (list), ahelate liigid.
    Abstraktsed andmetüübid
        "Varajane" OOP. Eesmärk: peita realisatsiooni detailid, anda rakenduse programmeerijale probleemorienteeritud liides.
        ADT - Abstract Data Type
            1. Lubatud väärtuste hulk (väärtusvaru)
            2. Lubatud operatsioonide hulk
            3. (Notatsioon - tähistused väärtuste ja operatsioonide jaoks)
            Näit. kompleksarvud, polünoomid, graafid, geomeetrilised kujundid, ...
        OOP muutis niisuguse lähenemise kohustuslikuks.
        Väärtusvaru järgi jagunemine:
            1. lihttüübid, mille väärtustel ei ole sisemist struktuuri: arv, tõeväärtus, ...
            2. struktuursed tüübid, mille väärtus koosneb komponentidest: massiiv, objekt (kirje), ...
        Operatsioonid on OOP-s "kinnistatud" objekti juurde (kapseldus).
            1. Kinnised operatsioonid: tulemus kuulub sama tüübi väärtusvarusse
            2. mittekinnised operatsioonid: tulemus on mingit teist tüüpi
            3. tüübiteisendused: tegelikud ja deklaratiivsed
            Näit. kinnine operatsioon "summa" (mis iganes see ka poleks)
        Imperatiivne lähenemine: m = summa (a, b) "funktsiooni summa parameetriteks on a ja b"
        OOP lähenemine: m = a.summa (b) "objektile a saadetakse teade 'summa' parameetriga b"
        Andmestruktuurid võib jagada:
            1. staatilised: komponentide arv ja tüübid fikseeritud: näiteks kompleksarv
            2. dünaamilised: väärtuse komponentide arv on muutuv, komponendid ise tavaliselt üht tüüpi: näiteks magasin, järjekord, graaf, ...
        Andmestruktuuride korral on oluliseks küsimuseks juurdepääsu tagamine komponentidele ning struktuuri muutmine (vastavate operatsioonide ajaline keerukus).
            "Võtmine" ja "lisamine".
8.Magasin (stack). Avaldise pööratud poola kuju (RPN).
    LIFO - last in first out
    Magasini omadused:
        1. dünaamiline struktuur (elementide arv on muutuv)
        2. elemendid on sama tüüpi
        3. elementide järjestus on oluline
        4. juurdepääs on ainult viimasena lisatud elemendile (magasini tipp); "lisamine" lisab lõppu ja "võtmine" eemaldab lõpust
        5. tavaliselt realiseeritavad operatsioonid: tühja magasini loomine, lisamine (push), võtmine (pop), alatäitumise (underflow) kontroll (et vältida tühjast magasinist võtmist),
           mõne realisatsiooni korral ka ületäitumise (overflow) kontroll (kas on "ruumi" lisamiseks), tipu lugemine ilma eemaldamiseta (optim. kaalutlustel)
    Keeles Java võib magasini realisatsiooni leida klassides java.util.Stack (baseerub vektoril) või java.util.LinkedList spetsialiseerides (baseerub topeltseotud ahelal).
    Magasini kasutamise näited: avaldise väärtustamine, 'return stack', puu läbimine, ...
    Avaldise postfikskuju ja selle interpreteerimine
        "Tavaline" infikskuju: (5-1) * 7 + 6 / 3
        Prefikskuju sulgudega: +( *( -( 5, 1), 7), /(6, 3))
        Postfikskuju sulgudega: (((5, 1)-, 7)*, (6, 3)/ )+
        Sulgudeta postfikskuju - nn. "pööratud poola kuju": 5 1 - 7 * 6 3 / + .
9.Järjekord (queue), järjekordade eriliigid.
    FIFO - First In First Out
    Järjekorra omadused:
        1. dünaamiline struktuur (elementide arv on muutuv)
        2. elemendid on sama tüüpi
        3. elementide järjestus on oluline
        4. juurdepääs on ainult esimesena lisatud elemendile (front); "lisamine" lisab lõppu ja "võtmine" eemaldab algusest (järjekorra metafoor)
        5. tavaliselt realiseeritavad operatsioonid: tühja järjekorra loomine, lisamine, võtmine, alatäitumise (underflow) kontroll (et vältida tühjast järjekorrast võtmist),
           mõne realisatsiooni korral ka ületäitumise (overflow) kontroll (kas on "ruumi" lisamiseks), vahendid järjekorra läbivaatamiseks (näit. iteraatorid vms.)
    Keeles Java võib järjekorra realisatsiooni luua klassi java.util.LinkedList spetsialiseerides (baseerub topeltseotud ahelal).
    Näiteid järjekorra kasutamise kohta: ressursside jagamine (printer), tegevuste planeerimine, graafi läbimine
    Eelistusjärjekord
        Järjekord, milles on olulised elementide (võtmete) väärtused. Prioriteetidega järjekord. "Lisamine" on sisuliselt hulgateoreetiline lisamine ja "võtmine" on vähima (suurima)
        võtmeväärtusega elemendi eemaldamine. Kui prioriteedid on staatilised (ei muutu elemendi järjekorras olemise ajal), siis saab "lisamise" teha pistemeetodi abil "Õigesse kohta".
    Muutuvate eelistustega järjekord
        Kui elemendi prioriteet võib elemendi järjekorras olemise ajal dünaamiliselt muutuda (niisugust järjekorda nim. muutuvate eelistustega järjekorraks),
        siis tuleb "võtmine" realiseerida järjekorra läbivaatusena ("lisamine" on selle eest lihtne). Teine võimalus on kajastada iga prioriteedimuutust kohe järjekorras,
        aga see ei pruugi olla hea lahendus (näiteks kui muutusi on palju, aga võtmisi vähe).
10.Puu, puu kujutamine. Suluesitused.
    Puu (programmeerimisalal tavaliselt järjestatud puu):
        dünaamiline andmestruktuur
        komponentideks nn. puu tipud: juurtipp e. juur, vahetipud, lehed (terminaalsed tipud)
        peegeldab ranget hierarhiat: juurtipp on kõige kõrgema taseme "ülemus", kõigil ülejäänud tippudel on täpselt üks ülemus (kasutatakse ka "vanemad-lapsed-vennad" metafoori)
        alluvateta tipud = puu lehed, kõik ülejäänud tipud on vahetipud
        sama ülemuse alluvad - kolleegid, naabrid
        järjestatud puu korral on oluline iga tipu alluvate (naabrite) omavaheline järjestus
    Näide:  aritmeetilise avaldise puu
        Infikskuju prioriteedisulgudega:  (5 - 1) * 7 + 6 / 3
        Prefikskuju sulgudega:  + (* (- (5, 1), 7), / (6, 3))
        Postfikskuju sulgudega:  (((5, 1)-, 7)*, (6, 3)/ )+
        Pööratud poola kuju:  5 1 - 7 * 6 3 / +
11.Puu läbimise viisid (põhialgoritmid).
    Eesjärjestus (pre-order):
        Töödelda juur
        Töödelda juure alampuud järjestuses vasakult paremale
    Lõppjärjestus (post-order, end-order):
        Töödelda juure alampuud järjestuses vasakult paremale
        Töödelda juur
    Kahendpuu läbimine keskjärjestuses (in-order)
        Töödelda vasak alampuu
        Töödelda juur
        Töödelda parem alampuu
    [VT. TREENODE / home5]
12.Graaf, graafiga seotud mõisted: orienteeritud ja orienteerimata graaf, multigraaf, lihtgraaf, sidusus, alamgraaf.
    G = (V, E) - graaf
        V - lõplik tippude hulk
        E c V x V (tipupaaride hulga alamhulk)
    Kui E elemente vaadeldakse kaheelemendiliste hulkadena (tippude järjekord paaris ei ole oluline), siis nimetatakse graafi orienteerimata graafiks ning hulka E graafi servade hulgaks.
    Kui E elemente vaadeldakse järjestatud tipupaaridena, siis nimetatakse graafi orienteeritud graafiks (digraph) ning hulka E graafi kaarte hulgaks.
    Graafiga seotud mõisteid
        Kui hulka E vaadeldakse multihulgana (element võib hulgas esineda mitmes eksemplaris), siis nimetatakse graafi multigraafiks (kordsete servade/ kaartega graafiks).
        Paari (v, v) hulgast E nim. silmuseks.
        Tippe u, v hulgast V nim. serva e=(u, v) otstippudeks, samuti öeldakse, et tipud u ja v on intsidentsed servaga e (orienteerimata graafis u ja v on naabertipud).
        Silmuste ja kordsete servadeta orienteerimata graafi nim. lihtgraafiks.
        Graafi G = (V, 0) nim. nullgraafiks (servade hulk on tühi).
        Lihtgraafi
            G = (V, VxV {(v, v)| v kuulub hulka V})
            nim. täisgraafiks (esinevad kõik erinevate tippude vahelised servad).
    Tee tipust u tippu v on paarikaupa ühiste otstippudega kaarte jada:
        (u, w0), (w0, w1), ... , (wn, v) kuuluvad hulka E .
    Orienteerimata graafi nim. sidusaks, (orienteeritud graafi tugevalt sidusaks) kui leidub tee mistahes tipust mistahes teise tippu.
    Orienteeritud graaf on nõrgalt sidus, kui kaarte suundade ärajätmisel saadav orienteerimata graaf on sidus.
    Graafi G1 = (V1, E1) nim. graafi G = (V, E) alamgraafiks, kui V1 on hulga V alamhulk ja E1 on E ühisosa hulgaga V1xV1
        (NB! mitte selle ühisosa alamhulk: alamhulga korral on tegemist nn. blokiga).
13.Graafi kujutamine, graafiga seotud maatriksid, tehted graafidega.
    1. Joonis (huvipakkuv probleem selles valdkonnas - tasandilised graafid).
    2. Kaarte loetelu (eeldades, et otstippude kohta käiv informatsioon on kaares olemas).
        Sellise loetelu organiseerimiseks on palju võimalusi.
    3. Külgnevusmaatriks (kaaslusmaatriks) jt. graafi ühest taastamist võimaldavad maatriksid.
    4. Külgnevusstruktuur - tippude loetelu, milles iga tipuga on seotud sellest lähtuvate kaarte loetelu (iga kaare kohta on teada tipp, kuhu ta suubub).
14.Graafi läbimise algoritmid: laiuti (breadth first) ja sügavuti (depth first).
    TODO!
15.Algoritmid graafidel: sidususkomponentide leidmine.
    Leida iga tipu v sidususkomponendi järjekorranumber k(v).
    Algselt kõigis tippudes k(v) = 0.
    Vaadeldava sidususkomponendi järjekorranumber n = 0.
    Tsükkel üle kõigi tippude v (kasutades külgnevusstruktuuri):
        kui k(v)==0, siis n=n+1 ning nummerdada kõik v-st saavutatavad tipud w numbriga n:
            k(w)=n.
16.Algoritmid graafidel: tippude topoloogiline järjestamine.
    TODO!
17.Algoritmid graafidel: kauguste arvutamine kõigi tipupaaride vahel.
    TODO!
18.Algoritmid graafidel: lühimate teede leidmine antud tipust.
    TODO!
19.Algoritmid graafidel: toesepuu (spanning tree).
    *Sidusa lihtgraafi (V, E) toesepuuks e. toeseks (spanning tree) nim. sidusat atsüklilist graafi (V, T), milles T on E alamhulk.
    *Kõik tipud on samad, servi on eemaldatud nii, et kaoksid tsüklid, aga sidusus säiliks. Toes ei ole üldjuhul üheselt määratud.
    *Kui servadel on mittenegatiivsed kaalud, siis pakub huvi niisuguse toese leidmine, mille kogukaal oleks minimaalne (kõigi toespuude hulgast).
    *Kruskali algoritm: järjestada servad kaalude järgi mittekahanevalt ning valida selle alusel järjekordne serv toesesse juba olemasolevate osapuude ühendamiseks (kui moodustub
    tsükkel, siis seda serva ei võeta). Alt-üles (alguses on üksikud tipud, lõpuks peavad kõik tipud esinema omas sidususkomponendis), ahne strateegia (valitakse hetkel parim tee).
    *Primi algoritm: töötatakse antud lähtetipust laiuti sarnaselt Dijkstra algoritmiga (toesesse valitakse hetkejätkudest minimaalse kaaluga serv,
    meeles peetakse kaalu ja eellast, vajadusel parandatakse eellast teel allikast antud tipuni).
20.Rekursioon, näide: Hanoi tornid. Rekursiooni eemaldamine, "sabarekursioon" (tail recursion).
    1. Rekursioon
        Rekursiivne algoritm sisaldab sellesama algoritmi poole pöördumist mingi "lihtsama juhu" jaoks.
        Tavaliselt saab eristada rekursiooni baasjuhtu ja sammu - analoogia matemaatilise induktsiooniga.
        Vormilt võib rekursioon olla
            otsene:   A ->  A
            kaudne:  A  ->  B  ->  ...  ->  A
        Näide. Faktoriaal
        0! = 1
        n! = n(n-1)!     kui n>0
        Rekursiivne definitsioon ei eelda rekursiivset programmi - tavaline tsükkel võib osutuda palju otstarbekamaks.
        Automaatne teisendamine "tsükkel - rekursioon"  ja "rekursioon - tsükkel".
            Näide. Fibonacci arvud (ebaotstarbekas realiseerida rekursiivse programmina)
            f(0) = 0
            f(1) = 1
            f(n) = f(n-1) + f(n-2)
    Rekursioon ei pruugi olla läbinähtav ülesande sõnastuses
    Näide. Hanoi tornid
        On n erineva läbimõõduga ketast, augud keskel, ning kolm varrat, millele kettaid saab laduda. Igal käigul tohib võtta ühe ketta ning tõsta selle mingile teisele vardale,
        kuid suuremat ketast ei tohi kunagi asetada väiksema peale. Eesmärgiks on laduda "torn" ainult lubatud käikude abil ühelt vardalt teisele (kolmandat varrast abiks võttes).
        Osutub, et ülesanne on eksponentsiaalse ajalise keerukusega ketaste arvu suhtes.
        Arutluskäik:
        Baasjuht: kui ketaste arv on null, siis ei ole tarvis mitte midagi teha.
        Samm: kui oskame laduda k-1 ketast vardalt a vardale b, siis k ketta ladumiseks vardalt x vardale z tuleb:
        laduda k-1 ketast vardalt x vardale y (võimalik eelduse põhjal)
        tõsta suurim ketas (k) vardalt x vardale z "põhjaks"
        laduda needsamad k-1 ketast vardalt y vardale z (võimalik eelduse põhjal)
        On oluline, et algseis (ja tegelikult ka mistahes järgnev seis) oleks lubatav.

        public static void hanoi (int n, int x, int y, int z) {
           if (n > 0) {
             hanoi (n-1, x, z, y);
             System.out.print (String.valueOf(x) + ">" + String.valueOf(z) + " "); // t6ste
    	  hanoi (n-1, y, x, z);
          }
         }
21.Ammendav otsing. Lippude paigutamise ülesanne (8 queens).
    Ammendav otsing (variantide läbivaatus)
    Teatud ülesannete korral on ainsaks täpseks lahendusmeetodiks "proovimise meetod", s.t. kõigi võimalike lahendusvariantide süstemaatiline läbivaatus (ammendav otsing).
    Kuna lõplikul n-elemendilisel hulgal on 2^n alamhulka, siis on ammendava otsingu ülesanne üldjuhtumil eksponentsiaalse keerukusega.
    Konkreetset keerukust saab teatud juhtudel vähendada otsinguruumi ahendamisega.
    Kaht liiki ülesanded:
        * esimese sobiva lahendi leidmine
        * kõigi lahendite leidmine
    Variandigeneraator - funktsioon lahendusvariantide süstemaatiliseks genereerimiseks.
    Tagasivõtt, backtracking: uue variandi valik antud tasemel, kui kõik alamjuhtumid on ammendatud.
    Näide. 8 lippu - kõigi lahendite leidmine.
    Paigutada malelauale 8 lippu nii, et ükski neist ei oleks mõne teise lipu tules.
    Idee: paigutada lippe järjekorras "vasakult paremale" nii, et n-nda lipu jaoks otsitakse kohta olukorras, kus eelnevad n-1 lippu on nõuetekohaselt paigutatud.
     Kui sobivat kohta n-ndas veerus ei leidu, siis vähendada n väärtust (backtracking) ning leida järgmine sobiv paigutus "eelmisele" lipule.
    Kujutame malelaua seisu ühemõõtmelise massiivina laud, mille iga element kodeerib ühe malelaua veeru järgmiselt:
    laud[j]=0 - veerus j ei ole lippu paigutatud
    laud[j]=i - veerus j paikneb lipp i-ndas reas (1 <= i <= 8)
    Predikaat onTules(n) : kas lipp number n on mõne eelneva lipu tules (samal real või diagonaalil, samas veerus ei saa olla juba seisu kujutusviisi tõttu).
22.Kahendpuu ja selle läbimine, kahendotsimise puu (binary search tree).
    1.Kahendpuu on puu, mille igal tipul on null kuni kaks alluvat, seejuures tehakse vahet vasakpoolse ja parempoolse alluva vahel.
    T on kahendpuu, kui kas:
        1. T on tühi
        2. T = (t0, Tv, Tp), kus t0on puu T juur, Tv on kahendpuu (vasak alampuu) ja Tp on kahendpuu (parem alampuu).
    Täielik kahendpuu sisaldab kõiki võimalikke tippe etteantud sügavusel (kõikidel vahetippudel on täpselt kaks alluvat);
        kui eemaldada järjest parempoolseimaid lehti, on igal sammul tulemuseks kompaktne kahendpuu.
    2.Kahendpuu läbimine
        Eesjärjestuses (pre-order):
            Kui T ei ole tühi, siis:
                1. töödelda juur
                2. läbida vasak alampuu eesjärjestuses
                3. läbida parem alampuu eesjärjestuses.
        Taga- e. lõppjärjestuses (post-order, end-order):
            Kui T ei ole tühi, siis:
                1. läbida vasak alampuu lõppjärjestuses
                2. läbida parem alampuu lõppjärjestuses
                3. töödelda juur.
        Keskjärjestuses (in-order):
            Kui T ei ole tühi, siis:
                1. läbida vasak alampuu keskjärjestuses
                2. töödelda juur
                3. läbida parem alampuu keskjärjestuses.
    3.Kahendotsimise puu
        Olgu kahendpuu iga tipuga t seotud võti t.x (võrreldavad väärtused).
            T.x olgu mittetühja kahendpuu T juure võti.
        Kahendotsimise puu on kahendpuu T, milles
            1. Kas T on tühi või
            2.
                A. iga tipu tv korral vasakust alampuust Tv kehtib tv.x <= T.x
                B. iga tipu tp korral paremast alampuust Tp kehtib tp.x >= T.x
                C. Tv ja Tp on kahendotsimise puud
    Kahendotsimise puu moodustamine = järjestamine
    Tasakaalustatud kahendpuu korral on Tv ja Tp enam-vähem võrdse suurusega (näit. kõrguste erinevus kuni 1).
23.AVL-puu, binomiaalpuu ja värvitud kahendpuu (red-black tree).
    TODO!
24.Kahendkuhi (binary heap)  ja sorteerimine kuhjameetodil (heap sort).
    Kuhjaomadus: puu ühegi tipu võti pole suurem kui tema ülemuse võti (mittekasvavad jadad juurest alla).
    Kahendkuhi (edaspidi lihtsalt kuhi) on kuhjaomadusega kompaktne kahendpuu. Suurim võti on puu juurtipus.
    Overview
        One simple way to sort a list of objects is to use a heap data structure. All elements to be sorted are inserted into a heap, and the heap organizes the elements added to it
        in such a way that either the largest value (in a max-heap) or the smallest value (in a min-heap) can be quickly extracted.
        Moreover, because this operation preserves the heap's structure, the largest/smallest value can be repeatedly extracted until none remain. This gives us the elements in order.

        In doing so, the only extra space required is that needed to store the heap. In order to achieve constant space overhead, we use a trick: we store a binary heap
        (or alternatively, a heap with more than two children) inside the part of the input array which has not yet been sorted. (The structure of this heap is described
        at Binary heap: Heap implementation.) Heapsort makes use of two standard heap operations: insertion and root deletion. Each time we delete (extract) the maximum,
        we place it in the last location of the array not yet occupied, and use the remaining prefix of the array as a heap holding the remaining unsorted elements:
25.m-rajaline otsimispuu, B-puu.
    B-puu
        Kahendotsimise puud võib üldistada m>2 juhtumile, lubades ühes puu tipus hoida kuni m-1 kirjet (m on konstant).
    m-rajaline otsimispuu on kas:
        1. tühi või
        2. koosneb juurest, milles hoitakse järjestatuna j võtit (0<=j<m) ning j+1 alampuust, mis kõik peavad olema kas mittetühjad m-rajalised otsimispuud või (kõik) tühjad puud.
        Juure võtmete k1 <= k2 <= ... <= kj ja alampuude T0, T1, ... , Tj jaoks kehtivad järgmised kitsendused:
            a. kõik alampuus T0 esinevad võtmed k ei ületa juure esimest võtit k1: k <= k1
            b. kõigi võtmete k jaoks alampuust Ti (0<i<j) kehtib ki <= k <= ki+1
            c. kõik alampuus Tj esinevad võtmed k pole väiksemad kui juure viimane võti kj: k >= kj
    m-järku B-puu (Bayer, McGreigh) on niisugune m-rajaline otsimispuu, milles
        1. kõik lehed on samal tasemel;
        2. lehed ei sisalda võtmeid (fiktiivsed, edaspidi jätame joonistel kujutamata);
        3. juurel on 2 kuni m alluvat;
        4. kõigil teistel vahetippudel on t=ceil[m/2] (t>=2) kuni m alluvat.
    Seega on juures 1 kuni m-1 võtit, vahetippudes t-1 kuni m-1 võtit.
    Tipp on täitunud, kui ta sisaldab m-1 võtit.
    Kõrgus h <= log t ((n+1)/2)
    Mahutavus n ~ O (2*(m/2)h)
    3-järku B-puu = 2-3 puu (igal vahetipul 2 või 3 alluvat).
    Otsimine: O(th)
    Lõigu "poolitamise" asemel otsitakse õigest alamlõigust (igal sammul kuni m valikut, kuni h sammu).
26.Sõnealgoritmid: Knuth-Morris-Pratt'i algoritm,  Rabin-Karp'i algoritm.
    Täpne otsimine
        Antud on:
            1. sõne t pikkusega n (n võib olla suur) - tekst
            2. sõne s pikkusega m (m <n) - muster, otsisõne
        Leida: kõik positsioonid k, mille korral muster s esineb tekstis t positsioonis k
        Naiivne algoritm selle ülesande lahendamiseks vaatab läbi kogu otsinguruumi, sobitades s kõikvõimalikesse positsioonidesse tekstis t, niisuguseid positsioone on
        n-m +1 tükki ja iga sobitus võtab halvimal juhul m võrdlust: seega on naiivse algoritmi keerukus O((n-m+1)m) ~ O(mn), m<n.
    Knuth-Morris-Pratti algoritm
        Naiivset algoritmi saab oluliselt parandada, analüüsides eelnevalt otsisõne struktuuri. Kui praegu "nihutatakse" mustrit igal sammul ühe positsiooni võrra,
        siis Knuth-Morris-Pratti algoritmis arvutatakse võimalikud nihked ette välja ning kantakse tabelisse, mida siis nihutamisel kasutatakse
        (tabelis sisalduvat nn. prefiksfunktsiooni võib tõlgendada ka lõpliku automaadi terminites).
    Prefiksfunktsiooni väärtus arvutatakse otsisõne s iga positsiooni i jaoks ning see on pikima sellise s prefiksi pikkus, mis on positsioonis i-1 lõppeva s alamsõne sufiksiks.
    Rabin-Karpi algoritm
        Täpse otsimise ülesannet oleme siiani lahendanud jõumeetodi parandamise teel pikemate hüpete suunas. Teine lähenemine on parandada otsisõne ja vastava tekstilõigu
        võrdlemise kiirust (seni O(m)). Sõnede võrdlemise asemel võrdleme nende räsisid (potentsiaalse valehäire hinnaga). Räsifunktsiooni väärtust arvutame järgneva tekstilõigu
        jaoks kasutades eelmise lõigu räsi. Selline lähenemine töötab siis, kui m ei ole suur ja tähestiku võimsus ei ole suur. Olgu näiteks tähestik { 0, 1, 2, ..., 9 }.
        Siis iga sõnet selles tähestikus esindab täisarv, mille kümnendkujuks see sõne on. Selle arvu väljaarvutamise keerukus on O(m). Samas saab mustri nihutamist paremale
        arvutada kiiremini (lahutame räsi väärtusest suurima järgu, korrutame tähestiku võimsusega ning lisame uue vähima järgu). Valehäired tekivad sellest, et me arvutame mingis
        jäägiklassiringis (ei ole otstarbekas arvutada väga suurte täisarvudega). Seega tuleb räside kokkulangemisel alati kontrollida, kas ka sõned tegelikult kokku langesid.
27.Sõnealgoritmid: Boyer-Moore'i algoritm.
    Ka Boyer-Moore'i algoritm pühendub "paremale hüppamisele" tekstis. Sobitamine toimub paremalt vasakule, prefiksfunktsiooni asemel arvutatakse sufiksfunktsioon ning lisaks
    veel sümboli nn. viimase esinemise funktsioon (iga sümboli viimase esinemise positsioon otsisõnes, mitteesinemisel null). Valitakse maksimaalne erinevate hüppevõimaluste vahel.
    Praktikas saavutatakse oluliselt pikemad hüpped, ideaaljuhul taandub keerukus O(n/m)-ni, halvim keerukus on O(mn).
28.Kodeerimine, kodeerimisskeemid, prefikskood. Shannon-Fano pakkimismeetod.
    1. Kodeerimine
        * Ruumi kokkuhoiuks (pakkimine, näit. Shannon-Fano, Huffmani ja Ziv-Lempeli koodid)
        * Edastusvigade automaatseks parandamiseks (näit. Hammingi koodid)
        * Krüptoloogia (salajase ja avaliku võtme krüptograafia, digiallkiri, sõnumilühendid jne.)
        Kodeerimisskeem on kujutus, mis seab lähtetekstile vastavusse kodeeritud teksti.
        Tähestikupõhine kodeerimisskeem vaatleb lähteteksti sümbolite kaupa ning seab igale sümbolile vastavusse tema koodi.
        Kui lähtetekst on koodi põhjal täpselt taastatav, siis nimetatakse seda üheseks kodeerimisskeemiks.
        Üheses kodeerimisskeemis kadusid ei esine:
            * erinevate sümbolite koodid on erinevad
            * kodeeritud tekstis saab koode eristada üheselt (ei leidu kahte erinevat lähteteksti, mis annaksid ühesuguse kodeeritud teksti)
        Viimast omadust saab tagada näiteks nn. prefikskoodide abil: ühegi sümboli kood ei ole mingi teise sümboli koodi prefiksis.
        Vaatleme edasises juhtu, kus koodi väljendatakse kahendsüsteemis (0-1).
            Siis saab kodeerimisskeemi kujutada kahendpuuna, mille lehtedeks on kodeeritavad sümbolid. Iga liikumine vasakusse alampuusse on kodeeritud nulliga,
            liikumine paremasse alampuusse ühega. Sümboli koodiks on bitijada, mis saadakse liikumisel selle kahendpuu juurest sümbolile vastava leheni.
        Eelpool kirjeldatud puud nimetatakse antud sümbolite hulga koodipuuks. Tegemist on prefikskoodiga, sest:
            * tee kahendpuu juurest leheni on üheselt määratud,
            * mistahes koodi prefiksile vastab koodipuus vahetipp, mitte kunagi leht.
        "Tavaline" kodeering on täielik 8-tasemeline kahendpuu (igale sümbolile vastab bitijada pikkusega 8).
    2.Pakkimine
        Kokkuhoidu mälumahus saab saavutada näiteks kasutades muutuva pikkusega koode - sagedamini esinevatel sümbolitel on lühike kood, harvaesinevatel pikem.
        Vajame infot sümbolite esinemissageduse kohta.
        Prefikskoodi kasutamisel oleks vaja koodipuu koostada nii, et sagedamini esinevad sümbolid oleksid juurele lähemal, harvemesinevad kaugemal.
29.Ahned (greedy) algoritmid. Pakkimine Huffmani puu abil.
    Huffmani puu antud teksti jaoks on niisugune koodipuu, mille abil kodeeritud teksti pikkus on minimaalne (kõikvõimalike koodipuude hulgas).
    Huffmani puu moodustamine:
        1. Kodeeritava teksti eeltöötlus: teeme kindlaks tekstis esinevate sümbolite hulga ning iga sümboli esinemissageduse. Seda etappi ei pruugi teha,
        kui kasutame mingit standardset ja ettearvutatud sagedustega tähestikku (aga siis ei tule skeem optimaalne).
        2. Moodustame tulevase koodipuu lehed, säilitades neis sümbolit ning selle esinemissagedust. Iga lehte käsitleme alampuu juurena.
        3. Valime kaks alampuud, mille juurest võetud esinemissagedused on vähimad kõigi alampuude hulgas (kui kaht puud enam valida ei saa, siis on algoritm oma töö lõpetanud).
        Moodustame nende kohale uue vahetipu, millesse salvestame alluvate esinemissageduste summa ning paneme valitud alampuud selle vahetipu vasakus ja paremaks alluvaks.
        4. Jätkame sammuga 3 niikaua, kuni enam kaht puud valida ei saa.
30.Dünaamiline kavandamine (dynamic programming). Pikima ühise osasõne leidmine.
    TODO!
31.Nõrgima eeltingimuse kasutamine algorimi osalise korrektsuse tõestamiseks.
    TODO!